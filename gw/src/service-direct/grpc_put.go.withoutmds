package service_direct

import (
	"bytes"
	"config"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"lib/glog"
	"lib/pool"
	"math/rand"
	pool2 "lib/pool"
	"log"
	"net/http"
	bitstore2 "service/dsspb"
//	mds2 "service/mdspb"
	"time"
	bitstore "service/dsspb"
//	mds "service/mdspb"
)

func UploadFileLogicGrpc(ctx *Context) {
	buf := bytes.NewBuffer(nil)
	buf.WriteString("ng-start: ")
	UploadCheck(ctx)
	if ctx.result.ErrorCode.StatusCode != http.StatusOK {
		return
	}
	ctx.dssStart = time.Now()
	defer func() {
		ctx.dssTime = time.Since(ctx.dssStart).Nanoseconds() / time.Millisecond.Nanoseconds()
	}()
	var t int
	t= rand.Int()%2
	conns, streams := getConns(ctx, t ,config.MasterMds[t])
	defer releaseConns(conns)
	if streams == nil {
		ctx.result = &Result{InternalError, fmt.Sprintf("grcp connect stream create error")}
		return
	}
	bufData, err := ioutil.ReadAll(ctx.reader)
	if err != nil {
		glog.Errorf("read file error: %v", err)
		ctx.result = &Result{InternalError, fmt.Sprintf("read file error: %v", err)}
	}
	for i := 0; i < int(1); i++ {

		if err != io.EOF && err != nil {
			glog.Errorf("read file error: %v", err)
			ctx.result = &Result{InternalError, fmt.Sprintf("read file error: %v", err)}
			break
		}
		ctx.size += int64(len(bufData))

		req := &bitstore.PutRequest{
			Offset: 524288,
			Length: uint64(len(bufData)),
			Data:   bufData,
		}

		for _, stream := range streams {
			go func(stream bitstore.BitStore_PutClient) {
				err := stream.Send(req)
				if err != nil {
					glog.Errorf("send file error: %v", err)
				}
				ctx.dssChan <- err
			}(stream)
		}
	}
	// wait for requests send finish
	for i := 0; i < int(1)*len(streams); i++ {
		<-ctx.dssChan
	}

	// close send request
	for _, stream := range streams {
		if err := stream.CloseSend(); err != nil {
			ctx.result = &Result{InternalError, fmt.Sprintf("close stream error: %v", err)}
			return
		}
	}
	dssRltChan := make(chan error)
	// receive replicate reply
	for _, stream := range streams {
		go func(stream bitstore.BitStore_PutClient) {
			resp, err := stream.CloseAndRecv()
			if err != nil {
				dssRltChan <- err
				return
			}
			if resp.Errcode < 0 {
				dssRltChan <- fmt.Errorf("dss resp error: %v", resp.Errcode)
				return
			}
			dssRltChan <- nil
		}(stream)
	}

	// wait for dss replicate finish
	for i := 0; i < len(streams); i++ {
		err := <-dssRltChan
		if err != nil {
			ctx.result = &Result{InternalError, err.Error()}
		}
	}
        buf.WriteString(fmt.Sprintf("DSS返回点:%v ",time.Since(ctx.start).Nanoseconds()))

	fmt.Println(buf.String())
}

func releaseConns(conns []pool.Conn) {
	for _, conn := range conns {
		conn.Close()
	}
}

func getdssaddrs(diskid int, mdsaddr string) []string {
	var addrs []string
	addrs = make([]string , 0, config.DssReplicateFactor+1)
	addrs =  append(addrs ,config.Mastermds2MasterDss[mdsaddr][diskid])
	for i:=0 ; i<config.DssReplicateFactor ; i++ {
		addrs = append(addrs , config.ReplicationDss[addrs[0]][i])
		log.Printf("addrs[%v] is %v",i+1,addrs[i+1])
	}
	return addrs
}

func getConns(ctx *Context, diskid int, mdsaddr string) ([]pool2.Conn, []bitstore2.BitStore_PutClient) {
	addrs := getdssaddrs(diskid,mdsaddr)
	conns := make([]pool.Conn, 0, len(addrs))
	streams := make([]bitstore.BitStore_PutClient, 0, len(addrs))

	for _, addr := range addrs {
		conn, err := config.DSSPool[addr].Get()
		if err != nil {
			ctx.result = &Result{InternalError, fmt.Sprintf("can't connect: %v", err)}
			return conns, nil
		}
		client := bitstore.NewBitStoreClient(conn.Value())
		stream, err := client.Put(context.Background())
		if err != nil {
			ctx.result = &Result{InternalError, fmt.Sprintf("put stream error: %v", err)}
			return conns, nil
		}

		conns = append(conns, conn)
		streams = append(streams, stream)
	}

	return conns, streams
}


func GenerateKeyGrpc() string {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	candidates := []byte(Characters)
	buf := bytes.NewBuffer(nil)
	count := len(Characters)
	for i := 0; i < KeySize; i++ {
		index := r.Intn(count)
		buf.WriteByte(candidates[index])
	}
	return fmt.Sprintf("%s%s", MagicNum, buf.String())
}

const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
const (
	letterIdxBits = 6                    // 6 bits to represent a letter index
	letterIdxMask = 1<<letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
	letterIdxMax  = 63 / letterIdxBits   // # of letter indices fitting in 63 bits
)

func RandStringBytesMaskImpr(n int) []byte {
	b := make([]byte, n)
	// A rand.Int63() generates 63 random bits, enough for letterIdxMax letters!
	for i, cache, remain := n-1, rand.Int63(), letterIdxMax; i >= 0; {
		if remain == 0 {
			cache, remain = rand.Int63(), letterIdxMax
		}
		if idx := int(cache & letterIdxMask); idx < len(letterBytes) {
			b[i] = letterBytes[idx]
			i--
		}
		cache >>= letterIdxBits
		remain--
	}

	return b
}

